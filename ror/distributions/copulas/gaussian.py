"""
Copyright 2023 ServiceNow
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

from .. import Copula

import numpy as np
import math
from scipy.stats import norm


class CustomGaussianCopula(Copula):
    """
    A Gaussian copula with an arbitrary covariance matrix.
    """

    def __init__(
        self,
        num_time: int,
        num_series: int,
        cov: np.array,
    ):
        assert (
            np.diag(cov) == 1
        ).all(), "The diagonal values of a covariance matrix should all be 1."
        assert cov.shape[0] == num_time * num_series
        assert cov.shape[1] == num_time * num_series

        self.num_time = num_time
        self.num_series = num_series
        self.cov = cov
        self.mean = np.zeros(num_time * num_series)

    def sample(self, num_samples: int, rng: np.random.Generator) -> np.array:
        # Shape = [num samples, num time steps, num series]
        x = rng.multivariate_normal(
            mean=self.mean, cov=self.cov, size=num_samples, check_valid="raise"
        )
        u = norm.cdf(x)
        return u.reshape(num_samples, self.num_time, self.num_series)

    def log_pdf(self, u):
        num_elements = self.num_time * self.num_series
        u = u.reshape(num_elements)

        x = norm.ppf(u, loc=0, scale=1)
        # dx/du = (du / dx)^-1, and u = cdf(x), thus du/dx = pdf(x)
        transform = norm.pdf(x)
        l_transform = -np.log(transform).sum()

        l1 = -(num_elements / 2) * math.log(2 * math.pi)
        l2 = -0.5 * math.log(np.abs(np.linalg.det(self.cov)))
        inv_cov = np.linalg.inv(self.cov)
        l3 = -0.5 * x @ inv_cov @ x

        return l_transform + l1 + l2 + l3


class DenseGaussianCopula(Copula):
    def __init__(
        self,
        num_time: int,
        num_series: int,
        rng: np.random.Generator,
        error_ratio: float = 0.0,
    ):
        self.num_time = num_time
        self.num_series = num_series

        self.mean = np.zeros(self.num_time * self.num_series)
        self.cov = self.initialize_cov_matrix(
            self.num_time * self.num_series, rng, error_ratio
        )

    @staticmethod
    def initialize_cov_matrix(
        num_elements: int, rng: np.random.Generator, error_ratio: float = 0.0
    ) -> np.array:
        """
        Generate a random semi-definite matrix of the given size.
        The matrix is generated by using ((1-e) * B + e*E) * ((1-e)*B + e*E)',
        where B is base (target), and E is another matrix for the fully erroneous forecasts.
        The result will be normalized such that the diagonal elements will all be equal to 1.
        """
        assert 0 <= error_ratio <= 1.0

        base = rng.normal(loc=0, scale=1, size=(num_elements, num_elements))
        error = rng.normal(loc=0, scale=1, size=(num_elements, num_elements))

        mat = (1 - error_ratio) * base + error_ratio * error
        cov = np.matmul(mat, mat.transpose())
        norm = np.diag(1.0 / np.sqrt(np.diag(cov)))

        return np.matmul(norm, np.matmul(cov, norm))

    def sample(self, num_samples: int, rng: np.random.Generator) -> np.array:
        # Shape = [num samples, num time steps, num series]
        x = rng.multivariate_normal(
            mean=self.mean, cov=self.cov, size=num_samples, check_valid="raise"
        )
        u = norm.cdf(x)
        return u.reshape(num_samples, self.num_time, self.num_series)
